# Comparing `tmp/abcvoting-2.7.1-py3-none-any.whl.zip` & `tmp/abcvoting-2.8.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 70360 bytes, number of entries: 17
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-29 11:24 abcvoting/__init__.py
--rw-r--r--  2.0 unx   163235 b- defN 23-Mar-29 11:24 abcvoting/abcrules.py
--rw-r--r--  2.0 unx    29677 b- defN 23-Mar-29 11:24 abcvoting/abcrules_gurobi.py
--rw-r--r--  2.0 unx    18039 b- defN 23-Mar-29 11:24 abcvoting/abcrules_mip.py
--rw-r--r--  2.0 unx     9643 b- defN 23-Mar-29 11:24 abcvoting/abcrules_ortools.py
--rw-r--r--  2.0 unx    16226 b- defN 23-Mar-29 11:24 abcvoting/fileio.py
--rw-r--r--  2.0 unx    38434 b- defN 23-Mar-29 11:24 abcvoting/generate.py
--rw-r--r--  2.0 unx    12941 b- defN 23-Mar-29 11:24 abcvoting/misc.py
--rw-r--r--  2.0 unx     6151 b- defN 23-Mar-29 11:24 abcvoting/output.py
--rw-r--r--  2.0 unx    11204 b- defN 23-Mar-29 11:24 abcvoting/preferences.py
--rw-r--r--  2.0 unx    60683 b- defN 23-Mar-29 11:24 abcvoting/properties.py
--rw-r--r--  2.0 unx    14692 b- defN 23-Mar-29 11:24 abcvoting/scores.py
--rw-r--r--  2.0 unx     1071 b- defN 23-Mar-29 11:25 abcvoting-2.7.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     7862 b- defN 23-Mar-29 11:25 abcvoting-2.7.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-29 11:25 abcvoting-2.7.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Mar-29 11:25 abcvoting-2.7.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1353 b- defN 23-Mar-29 11:25 abcvoting-2.7.1.dist-info/RECORD
-17 files, 391313 bytes uncompressed, 68176 bytes compressed:  82.6%
+Zip file size: 69951 bytes, number of entries: 17
+-rw-r--r--  2.0 unx        0 b- defN 23-Jul-04 13:59 abcvoting/__init__.py
+-rw-r--r--  2.0 unx   163258 b- defN 23-Jul-04 13:59 abcvoting/abcrules.py
+-rw-r--r--  2.0 unx    29677 b- defN 23-Jul-04 13:59 abcvoting/abcrules_gurobi.py
+-rw-r--r--  2.0 unx    18059 b- defN 23-Jul-04 13:59 abcvoting/abcrules_mip.py
+-rw-r--r--  2.0 unx     9643 b- defN 23-Jul-04 13:59 abcvoting/abcrules_ortools.py
+-rw-r--r--  2.0 unx    14376 b- defN 23-Jul-04 13:59 abcvoting/fileio.py
+-rw-r--r--  2.0 unx    38434 b- defN 23-Jul-04 13:59 abcvoting/generate.py
+-rw-r--r--  2.0 unx    12941 b- defN 23-Jul-04 13:59 abcvoting/misc.py
+-rw-r--r--  2.0 unx     6151 b- defN 23-Jul-04 13:59 abcvoting/output.py
+-rw-r--r--  2.0 unx    11253 b- defN 23-Jul-04 13:59 abcvoting/preferences.py
+-rw-r--r--  2.0 unx    60809 b- defN 23-Jul-04 13:59 abcvoting/properties.py
+-rw-r--r--  2.0 unx    14692 b- defN 23-Jul-04 13:59 abcvoting/scores.py
+-rw-r--r--  2.0 unx     1071 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7783 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1353 b- defN 23-Jul-04 13:59 abcvoting-2.8.0.dist-info/RECORD
+17 files, 389602 bytes uncompressed, 67767 bytes compressed:  82.6%
```

## zipnote {}

```diff
@@ -30,23 +30,23 @@
 
 Filename: abcvoting/properties.py
 Comment: 
 
 Filename: abcvoting/scores.py
 Comment: 
 
-Filename: abcvoting-2.7.1.dist-info/LICENSE
+Filename: abcvoting-2.8.0.dist-info/LICENSE
 Comment: 
 
-Filename: abcvoting-2.7.1.dist-info/METADATA
+Filename: abcvoting-2.8.0.dist-info/METADATA
 Comment: 
 
-Filename: abcvoting-2.7.1.dist-info/WHEEL
+Filename: abcvoting-2.8.0.dist-info/WHEEL
 Comment: 
 
-Filename: abcvoting-2.7.1.dist-info/top_level.txt
+Filename: abcvoting-2.8.0.dist-info/top_level.txt
 Comment: 
 
-Filename: abcvoting-2.7.1.dist-info/RECORD
+Filename: abcvoting-2.8.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## abcvoting/abcrules.py

```diff
@@ -3734,15 +3734,15 @@
             The algorithm to be used.
 
             The following algorithms are available for the maximin support method (MMS):
 
             .. doctest::
 
                 >>> Rule("maximin-support").algorithms
-                ('gurobi',)
+                ('gurobi', 'mip-gurobi', 'mip-cbc')
 
         resolute : bool, optional
             Return only one winning committee.
 
             If `resolute=False`, all winning committees are computed (subject to
             `max_num_of_committees`).
 
@@ -3790,15 +3790,15 @@
     # optional output
     output.info(header(rule.longname), wrap=False)
     if not resolute:
         output.info("Computing all possible winning committees for any tiebreaking order")
         output.info(" (aka parallel universes tiebreaking) (resolute=False)\n")
     output.details(f"Algorithm: {ALGORITHM_NAMES[algorithm]}\n")
     if resolute:
-        output.details(f"starting with the empty committee\n")
+        output.details("starting with the empty committee\n")
         committee = []
         for i, next_cand in enumerate(detailed_info["next_cand"]):
             tied_cands = detailed_info["tied_cands"][i]
             support_value = detailed_info["support_value"][i]
             committee.append(next_cand)
             output.details(f"adding candidate number {i+1}: {profile.cand_names[next_cand]}")
             output.details(
```

## abcvoting/abcrules_mip.py

```diff
@@ -382,16 +382,16 @@
 
 def _mip_maximin_support_scorefct(profile, base_committee, solver_id):
     """Uses an LP to compute the maximin support values obtained when adding any
     candidate to the committee.
 
     Based on the LP described in the proof of Theorem 4.2 of
     L. Sánchez-Fernández et al.
-    The maximin support method: an extension of the D'Hondt method to approval-based multiwinner elections
-    Mathematical Programming (2022)
+    The maximin support method: an extension of the D'Hondt method to approval-based multiwinner
+    elections. Mathematical Programming (2022)
     """
 
     scores = [0] * profile.num_cand
     remaining_candidates = [cand for cand in profile.candidates if cand not in base_committee]
 
     for added_cand in remaining_candidates:
         committee = set(base_committee) | {added_cand}
@@ -423,15 +423,16 @@
         model.opt_tol = ACCURACY
 
         model.objective = minimum
         status = model.optimize()
 
         if status != mip.OptimizationStatus.OPTIMAL:
             raise RuntimeError(
-                f"Python MIP returned an unexpected status code: {status} while computing the maximin support score."
+                f"Python MIP returned an unexpected status code: {status} "
+                "while computing the maximin support score."
             )
 
         scores[added_cand] = minimum.x
 
     return scores
```

## abcvoting/fileio.py

```diff
@@ -3,16 +3,16 @@
 
 Two data formats are supported:
 1. the Preflib format (soi, toi, soc or toc), and
 2. .abc.yaml files (more expressive than Preflib files).
 """
 
 import os
-from math import ceil
 import ruamel.yaml
+import preflibtools.instances as preflib
 from abcvoting.preferences import Profile, Voter
 from abcvoting import misc
 
 
 #: Valid keys for .abc.yaml files.
 ABC_YAML_VALID_KEYS = [
     "profile",
@@ -58,246 +58,194 @@
     if filename_extensions:
         files = [
             f for f in files if any(f.endswith(extension) for extension in filename_extensions)
         ]
     return sorted(files)
 
 
-def _approval_set_from_preflib_datastructures(num_appr, ranking, candidate_map):
-    # if num_appr = 1 and the ranking starts with empty set, interpret as empty ballot and
-    # return set()
-    if (
-        num_appr == 1
-        and ranking[0].strip()[0] == "{"
-        and ranking[0].strip()[-1] == "}"
-        and ranking[0].strip().replace("}", "").replace("{", "").strip() == ""
-    ):
-        return set()
-
-    approval_set = set()
-    tied = False
-    for rank in ranking:
-        rank = rank.strip()
-        if rank.startswith("{"):
-            if not tied:
-                tied = True
-                rank = rank[1:]
-            else:
-                raise MalformattedFileException(
-                    "Invalid format for tied candidates: " + str(ranking)
-                )
-        if rank.endswith("}"):
-            if tied:
-                tied = False
-                rank = rank[:-1]
-            else:
-                raise MalformattedFileException(
-                    "Invalid format for tied candidates: " + str(ranking)
-                )
-        rank = rank.strip()
-        if len(rank) > 0:
-            try:
-                cand = int(rank)
-            except ValueError as error:
-                raise MalformattedFileException(
-                    f"Expected candidate number but encountered {rank}"
-                ) from error
-            approval_set.add(cand)
-        if len(approval_set) >= num_appr and not tied:
-            break
-    if tied:
-        raise MalformattedFileException("Invalid format for tied candidates: " + str(ranking))
-    if len(approval_set) < num_appr:
-        # all candidates approved
-        approval_set = set(candidate_map.keys())
-    return approval_set
-
-
-def read_preflib_file(filename, setsize=1, relative_setsize=None, use_weights=False):
+def read_preflib_file(filename, top_ranks=None, setsize=None, use_weights=False):
     """
     Read a Preflib file (soi, toi, soc or toc).
 
     Parameters
     ----------
         filename : str
             Name of the Preflib file.
 
-        setsize : int
+        top_ranks : int, default=1
+            The approval set consists of the top entries in each voter's ranking in the Preflib
+            instance. The parameter `top_ranks` determines how many ranks are joined to create
+            the approval set. In case of of a Preflib category files, ranks correspond to
+            categories.
+
+            It cannot be used if parameter `setsize` is used too.
+
+        setsize : int, optional
             Minimum number of candidates that voters approve.
 
             These candidates are taken from the top of ranking.
             In case of ties, more than setsize candidates are approved.
 
-            Paramer `setsize` is ignored if `relative_setsize` is used.
-
-        relative_setsize : float
-            Proportion (number between 0 and 1) of candidates that voters approve (rounded up).
-
-            In case of ties, more candidates are approved.
-            E.g., if there are 10 candidates and `relative_setsize=0.75`,
-            then the voter approves the top 8 candidates.
+            It cannot be used if parameter `top_ranks` is used too.
 
         use_weights : bool, default=False
             Use weights of voters instead of individual voters.
 
             If False, treat vote count in Preflib file as the number of identical ballots,
             i.e., the number of voters that approve this set of candidates.
             If True, treat vote count as weight and use this weight in class Voter.
 
     Returns
     -------
         abcvoting.preferences.Profile
             Preference profile extracted from Preflib file.
     """
-    if setsize <= 0:
+    if top_ranks is None and setsize is None:
+        top_ranks = 1  # default
+    if top_ranks and setsize:
+        raise ValueError("Parameters top_ranks and setsize cannot be used simultaneously.")
+    if top_ranks and top_ranks <= 0:
+        raise ValueError("Parameter top_ranks must be > 0")
+    if setsize and setsize <= 0:
         raise ValueError("Parameter setsize must be > 0")
-    if relative_setsize and (relative_setsize <= 0.0 or relative_setsize > 1.0):
-        raise ValueError("Parameter relative_setsize not in interval (0, 1]")
-    with open(filename) as f:
-        line = f.readline()
-        num_cand = int(line.strip())
-        candidate_map = {}
-        for _ in range(num_cand):
-            parts = f.readline().strip().split(",")
-            candidate_map[int(parts[0].strip())] = ",".join(parts[1:]).strip()
-
-        parts = f.readline().split(",")
-        try:
-            voter_count, _, unique_orders = (int(p.strip()) for p in parts)
-        except ValueError as error:
-            raise MalformattedFileException(
-                f"Number of voters ill specified ({str(parts)}), should be triple of integers"
-            ) from error
-
-        approval_sets = []
-        lines = [line.strip() for line in f.readlines() if line.strip()]
-        if len(lines) != unique_orders:
-            raise MalformattedFileException(
-                f"Expected {unique_orders} lines that specify voters in the input, "
-                f"encountered {len(lines)}"
-            )
 
-    for line in lines:
-        parts = line.split(",")
-        if len(parts) < 1:
-            continue
-        try:
-            count = int(parts[0])
-        except ValueError as error:
-            raise MalformattedFileException(
-                f"Each ranking must start with count/weight ({line})."
-            ) from error
-        ranking = parts[1:]  # ranking starts after count
-        if len(ranking) == 0:
-            raise MalformattedFileException("Empty ranking: " + str(line))
-        if relative_setsize:
-            num_appr = int(ceil(len(ranking) * relative_setsize))
-        else:
-            num_appr = setsize
-        approval_set = _approval_set_from_preflib_datastructures(num_appr, ranking, candidate_map)
-        approval_sets.append((count, approval_set))
+    try:
+        preflib_inst = preflib.get_parsed_instance(filename)
+    except Exception as e:
+        raise MalformattedFileException(
+            "The preflib parser returned the following error: " + str(e)
+        )
+
+    if isinstance(preflib_inst, preflib.OrdinalInstance):
+        if setsize:
+            preflib_inst = preflib.CategoricalInstance.from_ordinal(
+                preflib_inst, size_truncators=[setsize]
+            )
+        elif top_ranks:
+            preflib_inst = preflib.CategoricalInstance.from_ordinal(
+                preflib_inst, num_indif_classes=[1] * preflib_inst.num_alternatives
+            )
+    elif not isinstance(preflib_inst, preflib.CategoricalInstance):
+        raise ValueError("Only ordinal and categorical preferences can be converted from PrefLib")
 
     # normalize candidates to 0, 1, 2, ...
     cand_names = []
     normalize_map = {}
-    for cand, name in candidate_map.items():
+    for cand, name in preflib_inst.alternatives_name.items():
         cand_names.append(name)
         normalize_map[cand] = len(cand_names) - 1
 
-    profile = Profile(num_cand, cand_names=cand_names)
+    profile = Profile(preflib_inst.num_alternatives, cand_names=cand_names)
+
+    for preferences, count in preflib_inst.multiplicity.items():
+        approval_set = []
+        if setsize:
+            category = 0
+            while len(approval_set) < setsize and category < len(preferences):
+                approval_set.extend([normalize_map[cand] for cand in preferences[category]])
+                category += 1
+            if 0 < len(approval_set) < setsize:
+                approval_set = normalize_map.values()
+        elif top_ranks:
+            approval_set = [
+                normalize_map[cand]
+                for category in range(min(len(preferences), top_ranks))
+                for cand in preferences[category]
+            ]
 
-    for count, approval_set in approval_sets:
-        normalized_approval_set = []
-        for cand in approval_set:
-            normalized_approval_set.append(normalize_map[cand])
         if use_weights:
-            profile.add_voter(Voter(normalized_approval_set, weight=count))
+            profile.add_voter(Voter(approval_set, weight=count))
         else:
-            profile.add_voters([normalized_approval_set] * count)
-    if use_weights:
-        if len(profile) != unique_orders:
-            raise MalformattedFileException("Number of voters wrongly specified in preflib file.")
-    else:
-        if len(profile) != voter_count:
-            raise MalformattedFileException("Number of voters wrongly specified in preflib file.")
+            profile.add_voters([approval_set] * count)
+
     return profile
 
 
-def read_preflib_files_from_dir(dir_name, setsize=1, relative_setsize=None):
+def read_preflib_files_from_dir(dir_name, top_ranks=None, setsize=None):
     """
     Read all Preflib files (soi, toi, soc or toc) in a given directory.
 
     Parameters
     ----------
         dir_name : str
             Path of the directory to be searched for Preflib files.
 
+        top_ranks : int, default=1
+            The approval set consists of the top entries in each voter's ranking in the Preflib
+            instance. The parameter `top_ranks` determines how many ranks are joined to create
+            the approval set. In case of of a Preflib category files, ranks correspond to
+            categories.
+
+            It cannot be used if parameter `setsize` is used too.
+
         setsize : int
             Minimum number of candidates that voters approve.
 
             These candidates are taken from the top of ranking.
             In case of ties, more than setsize candidates are approved.
 
-            Paramer `setsize` is ignored if `relative_setsize` is used.
-
-        relative_setsize : float
-            Proportion (number between 0 and 1) of candidates that voters approve (rounded up).
-
-            In case of ties, more candidates are approved.
-            E.g., if there are 10 candidates and `relative_setsize=0.75`,
-            then the voter approves the top 8 candidates.
+            It cannot be used if parameter `top_ranks` is used too.
 
     Returns
     -------
         dict
             Dictionary with file names as keys and profiles (class abcvoting.preferences.Profile)
             as values.
     """
-    files = get_file_names(dir_name, filename_extensions=[".soi", ".toi", ".soc", ".toc"])
+    files = get_file_names(dir_name, filename_extensions=[".soi", ".toi", ".soc", ".toc", ".cat"])
 
     profiles = {}
     for f in files:
         profile = read_preflib_file(
-            os.path.join(dir_name, f), setsize=setsize, relative_setsize=relative_setsize
+            os.path.join(dir_name, f), top_ranks=top_ranks, setsize=setsize
         )
         profiles[f] = profile
     return profiles
 
 
-def write_profile_to_preflib_toi_file(filename, profile):
+def write_profile_to_preflib_cat_file(filename, profile):
     """
-    Write a profile to a Preflib .toi file.
+    Write a profile to a Preflib category file (.cat).
 
     Parameters
     ----------
         filename : str
             File name of the Preflib file.
 
         profile : abcvoting.preferences.Profile
             Profile to be written.
 
     Returns
     -------
         None
     """
-    with open(filename, "w") as f:
-        # write: number of candidates
-        f.write(str(profile.num_cand) + "\n")
-        # write: names of candidates
-        for cand in profile.candidates:
-            f.write(f"{cand + 1}, {profile.cand_names[cand]}\n")
-        # write: info about number of voters and total weight
-        total_weight = sum(voter.weight for voter in profile)
-        f.write(f"{total_weight}, {total_weight}, {len(profile)}\n")
-        # write: approval sets and weights
-        for voter in profile:
-            str_approval_set = misc.str_set_of_candidates(
-                voter.approved, cand_names=list(range(1, profile.num_cand + 1))
-            )
-            f.write(f"{voter.weight}, {str_approval_set}\n")
+    preflib_inst = preflib.CategoricalInstance()
+    preflib_inst.num_categories = 2
+    preflib_inst.categories_name = {"1": "Approved", "2": "Not approved"}
+    preflib_inst.file_name = filename
+    preflib_inst.num_alternatives = profile.num_cand
+    for cand in profile.candidates:
+        preflib_inst.alternatives_name[cand + 1] = profile.cand_names[cand]
+
+    for voter in profile:
+        pref = (
+            tuple(cand + 1 for cand in voter.approved),
+            tuple(cand + 1 for cand in profile.candidates if cand not in voter.approved),
+        )
+        if int(voter.weight) == voter.weight:
+            multiplicity = voter.weight
+        else:
+            multiplicity = 1
+        if pref not in preflib_inst.preferences:
+            preflib_inst.preferences.append(pref)
+            preflib_inst.multiplicity[pref] = multiplicity
+        else:
+            preflib_inst.multiplicity[pref] += multiplicity
+    preflib_inst.recompute_cardinality_param()
+    preflib_inst.write(filename)
 
 
 def _yaml_flow_style_list(x):
     yamllist = ruamel.yaml.comments.CommentedSeq(x)
     yamllist.fa.set_flow_style()
     return yamllist
```

## abcvoting/preferences.py

```diff
@@ -331,15 +331,16 @@
     ----------
         approved : CandidateSet
             The set of approved candidates.
 
         weight : int or Fraction, default=1
             The weight of the voter.
 
-            This should not be used as the number of voters with these approved candidates.
+            If `weight` is an integer, the voter is interpreted as if there are `weight`
+            many voters with the same approval set.
 
         num_cand : int, optional
             The maximum number of candidates. Used only for checks.
 
             If this `num_cand` is provided, it is verified that `approved` does not contain
             numbers `>= num_cand`.
     """
```

## abcvoting/properties.py

```diff
@@ -291,15 +291,16 @@
     committee = CandidateSet(committee, num_cand=profile.num_cand)
 
     if algorithm == "fastest":
         algorithm = "gurobi"
 
     if not profile.has_unit_weights() and algorithm == "brute-force":
         raise NotImplementedError(
-            "For profiles with non-unit weights, check_EJR currently only supports the algorithm 'gurobi'."
+            "For profiles with non-unit weights, "
+            "check_EJR currently only supports the algorithm 'gurobi'."
         )
 
     if algorithm == "brute-force":
         result, detailed_information = _check_EJR_brute_force(profile, committee, quota)
     elif algorithm == "gurobi":
         result, detailed_information = _check_EJR_gurobi(profile, committee, quota)
     else:
@@ -320,15 +321,16 @@
         ell = detailed_information["ell"]
         cands = detailed_information["joint_candidates"]
         cohesive_group = detailed_information["cohesive_group"]
         fractional_size = sum(profile[vi].weight for vi in cohesive_group) / profile.total_weight()
         fractional_size = sum(profile[vi].weight for vi in cohesive_group) / profile.total_weight()
         output.details(
             f"(The {ell}-cohesive group of voters {str_set_of_candidates(cohesive_group)}"
-            f" ({fractional_size*100:.1f}% of all voters{' (by weight)' if not profile.has_unit_weights() else ''})"
+            f" ({fractional_size*100:.1f}% of all voters"
+            f"{' (by weight)' if not profile.has_unit_weights() else ''})"
             f" jointly approve the candidates {str_set_of_candidates(cands)}, but none of them "
             f"approves {ell} candidates in the committee.)",
             indent=" ",
         )
 
     return result
 
@@ -405,15 +407,16 @@
     committee = CandidateSet(committee, num_cand=profile.num_cand)
 
     if algorithm == "fastest":
         algorithm = "gurobi"
 
     if not profile.has_unit_weights() and algorithm == "brute-force":
         raise NotImplementedError(
-            "For profiles with non-unit weights, check_PJR currently only supports the algorithm 'gurobi'."
+            "For profiles with non-unit weights, check_PJR "
+            "currently only supports the algorithm 'gurobi'."
         )
 
     if algorithm == "brute-force":
         result, detailed_information = _check_PJR_brute_force(profile, committee, quota)
     elif algorithm == "gurobi":
         result, detailed_information = _check_PJR_gurobi(profile, committee, quota)
     else:
@@ -433,15 +436,16 @@
     if not result:
         ell = detailed_information["ell"]
         cands = detailed_information["joint_candidates"]
         cohesive_group = detailed_information["cohesive_group"]
         fractional_size = sum(profile[vi].weight for vi in cohesive_group) / profile.total_weight()
         output.details(
             f"(The {ell}-cohesive group of voters {str_set_of_candidates(cohesive_group)}"
-            f" ({fractional_size*100:.1f}% of all voters{' (by weight)' if not profile.has_unit_weights() else ''})"
+            f" ({fractional_size*100:.1f}% of all voters"
+            f"{' (by weight)' if not profile.has_unit_weights() else ''})"
             f" jointly approve the candidates {str_set_of_candidates(cands)}, but they "
             f"approve fewer than {ell} candidates in the committee.)"
         )
 
     return result
 
 
@@ -528,15 +532,16 @@
 
     if not result:
         cand = detailed_information["joint_candidate"]
         cohesive_group = detailed_information["cohesive_group"]
         fractional_size = sum(profile[vi].weight for vi in cohesive_group) / profile.total_weight()
         output.details(
             f"(The 1-cohesive group of voters {str_set_of_candidates(cohesive_group)}"
-            f" ({fractional_size*100:.1f}% of all voters{' (by weight)' if not profile.has_unit_weights() else ''})"
+            f" ({fractional_size*100:.1f}% of all voters"
+            f"{' (by weight)' if not profile.has_unit_weights() else ''})"
             f" jointly approve candidate {profile.cand_names[cand]}, but none of them"
             " approve a candidate in the committee.)"
         )
 
     return result
 
 
@@ -1057,15 +1062,16 @@
     if not result:
         cand = detailed_information["joint_candidate"]
         cohesive_group = detailed_information["cohesive_group"]
         ell = detailed_information["ell"]
         fractional_size = sum(profile[vi].weight for vi in cohesive_group) / profile.total_weight()
         output.details(
             f"(The group of voters {str_set_of_candidates(cohesive_group)}"
-            f" ({fractional_size*100:.1f}% of all voters{' (by weight)' if not profile.has_unit_weights() else ''})"
+            f" ({fractional_size*100:.1f}% of all voters"
+            f"{' (by weight)' if not profile.has_unit_weights() else ''})"
             f" deserves {ell} candidates,"
             f" and jointly approve candidate {profile.cand_names[cand]} which is not part of the"
             f" committee, but no member approves at least {ell} members of the committee.)"
         )
 
     return result
 
@@ -1407,15 +1413,16 @@
         ell = detailed_information["ell"]
         beta = detailed_information["beta"]
         cands = detailed_information["joint_candidates"]
         cohesive_group = detailed_information["cohesive_group"]
         fractional_size = sum(profile[vi].weight for vi in cohesive_group) / profile.total_weight()
         output.details(
             f"(The weakly cohesive group of voters {str_set_of_candidates(cohesive_group)}"
-            f"({fractional_size*100:.1f}% of all voters{' (by weight)' if not profile.has_unit_weights() else ''})"
+            f"({fractional_size*100:.1f}% of all voters"
+            f"{' (by weight)' if not profile.has_unit_weights() else ''})"
             f"each approve at least {beta} of the {ell} candidates {str_set_of_candidates(cands)},"
             f"but all approve at most {beta - 1} candidates in the committee.)",
             indent=" ",
         )
     return result
 
 
@@ -1611,15 +1618,16 @@
 
     if not result:
         objection = detailed_information["objection"]
         coalition = detailed_information["coalition"]
         fractional_size = sum(profile[vi].weight for vi in coalition) / profile.total_weight()
         output.details(
             f"(The group of voters {str_set_of_candidates(coalition)}"
-            f" ({fractional_size*100:.1f}% of all voters{' (by weight)' if not profile.has_unit_weights() else ''})"
+            f" ({fractional_size*100:.1f}% of all voters"
+            f"{' (by weight)' if not profile.has_unit_weights() else ''})"
             f" can block the outcome by proposing {str_set_of_candidates(objection)},"
             f" in which each group member approves strictly more candidates.)"
         )
 
     return result
```

## Comparing `abcvoting-2.7.1.dist-info/LICENSE` & `abcvoting-2.8.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `abcvoting-2.7.1.dist-info/METADATA` & `abcvoting-2.8.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: abcvoting
-Version: 2.7.1
+Version: 2.8.0
 Summary: A Python library of approval-based committee (ABC) rules
 Home-page: https://github.com/martinlackner/abcvoting/
 Author: Martin Lackner
 Author-email: unexpected@sent.at
 License: MIT License
 Project-URL: Bug Tracker, https://github.com/martinlackner/abcvoting/issues
 Classifier: Programming Language :: Python :: 3
@@ -20,27 +20,27 @@
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: networkx[default] (>=2.6.3)
 Requires-Dist: mip (>=1.14.0)
 Requires-Dist: ruamel.yaml (>=0.17)
 Requires-Dist: numpy (>=1.21)
 Requires-Dist: gurobipy (>=9.5.0)
+Requires-Dist: preflibtools (>=2.0.12)
 Provides-Extra: dev
 Requires-Dist: pytest (>=6) ; extra == 'dev'
 Requires-Dist: coverage[toml] (>=5.3) ; extra == 'dev'
 Requires-Dist: black (==22.3.0) ; extra == 'dev'
 Requires-Dist: Sphinx (>=4.4.0) ; extra == 'dev'
 Requires-Dist: sphinx-rtd-theme (>=1.0.0) ; extra == 'dev'
 Requires-Dist: numpydoc (>=1.2) ; extra == 'dev'
 Requires-Dist: sphinx-codeautolink (>=0.10) ; extra == 'dev'
 Requires-Dist: matplotlib (>=3.4.3) ; extra == 'dev'
 
 [![DOI](https://zenodo.org/badge/192713860.svg)](https://zenodo.org/badge/latestdoi/192713860)
 [![DOI](https://joss.theoj.org/papers/10.21105/joss.04880/status.svg)](https://doi.org/10.21105/joss.04880)
-[![MIT License](https://badgen.net/github/license/martinlackner/abcvoting)](https://choosealicense.com/licenses/mit/)
 [![PyPi](https://badgen.net/pypi/v/abcvoting)](https://pypi.org/project/abcvoting/)
 ![Python versions](https://badgen.net/pypi/python/abcvoting)
 [![Build badge](https://github.com/martinlackner/abcvoting/workflows/Build/badge.svg)](https://github.com/martinlackner/abcvoting/actions)
 [![Unittests badge](https://github.com/martinlackner/abcvoting/workflows/Unittests/badge.svg)](https://github.com/martinlackner/abcvoting/actions)
 [![docs](https://readthedocs.org/projects/abcvoting/badge/?version=latest&style=plastic)](https://abcvoting.readthedocs.io/en/latest/)
 [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
 [![codecov](https://codecov.io/gh/martinlackner/abcvoting/branch/master/graph/badge.svg)](https://codecov.io/gh/martinlackner/abcvoting)
```

## Comparing `abcvoting-2.7.1.dist-info/RECORD` & `abcvoting-2.8.0.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 abcvoting/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-abcvoting/abcrules.py,sha256=b0SBcfvO-yKHNl2N4qvxOE8XZfgjuUljvLuW3zcNxeU,163235
+abcvoting/abcrules.py,sha256=yjLhKEtX8WLLHfxc166Eqfl6iLKaR35edAQvVlqOui8,163258
 abcvoting/abcrules_gurobi.py,sha256=ABTbYgK7LxPPoCrG1JezJ56RqzEipcM8tws-wCXCTOA,29677
-abcvoting/abcrules_mip.py,sha256=h48m0Xq5dzKNa5DdGtTH83GAegwXwILyJqp31zgywkg,18039
+abcvoting/abcrules_mip.py,sha256=CA3gWtx5SAaShDlQbrycm4p1Lhfs8QBvmDUoxDr6I04,18059
 abcvoting/abcrules_ortools.py,sha256=Fhstb21gVU2wVPWHV70jWOKP62SUTAy-SgWESpIenbs,9643
-abcvoting/fileio.py,sha256=D1XmuIJyGCCcYJoc07jr_iAbinLWlVsJTdfjKbmqhEc,16226
+abcvoting/fileio.py,sha256=X2iRls5Iiyu1KDuqV1OguxUaYeiak7hmvAYsN6YZ6dI,14376
 abcvoting/generate.py,sha256=wZB99BPemIlvZEgASpo0HNpD2outB01yukeBZ_rtmkw,38434
 abcvoting/misc.py,sha256=TsAB_LyaSgBq3zww04YdqDxKeVRTWvXa1KqQ0ZeIryk,12941
 abcvoting/output.py,sha256=bD4LWIcNOfV7XeqaCYXNyb-lKn5QRVT_h0eD6MqDvMA,6151
-abcvoting/preferences.py,sha256=7JRsNfcZJTNyQ9rUE6WkxEY_XfvVRoOyex_rrOWfbRg,11204
-abcvoting/properties.py,sha256=FwbbVyef4HQqc9SoxCkCJavvF7qB1kFec91HVvH0mRU,60683
+abcvoting/preferences.py,sha256=l95d2pgPDqLMTqlNCxr6BqDhQ4B1BTQfV9UJGt4y_Jk,11253
+abcvoting/properties.py,sha256=vG89ZpZ406LkDE8RElCmYVV-TqPYtZLz54HK5H1x_Qk,60809
 abcvoting/scores.py,sha256=oHlolGYom9UEPvWZFElI21v_PFVvm3bRRpjqdWC2IAo,14692
-abcvoting-2.7.1.dist-info/LICENSE,sha256=zGd2CLhEHQwEF_aLnpMnFDcyFG5OPJ20CxPNalkkdPo,1071
-abcvoting-2.7.1.dist-info/METADATA,sha256=YX9SI5ZJE7r9Sn2w9GqyobpqYxB9znG1nppd64B4N50,7862
-abcvoting-2.7.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-abcvoting-2.7.1.dist-info/top_level.txt,sha256=960L_hveJVZkHrbdTu94Hppp6fnwbG-REV5RxlFhKFA,10
-abcvoting-2.7.1.dist-info/RECORD,,
+abcvoting-2.8.0.dist-info/LICENSE,sha256=zGd2CLhEHQwEF_aLnpMnFDcyFG5OPJ20CxPNalkkdPo,1071
+abcvoting-2.8.0.dist-info/METADATA,sha256=5iJfg_6O-gKj3F4H5gxzxG-iOLX7p0CbxIsDR3ao5vM,7783
+abcvoting-2.8.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+abcvoting-2.8.0.dist-info/top_level.txt,sha256=960L_hveJVZkHrbdTu94Hppp6fnwbG-REV5RxlFhKFA,10
+abcvoting-2.8.0.dist-info/RECORD,,
```

